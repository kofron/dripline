* Authentication.  We could definitely use authentication if we want to
continue to support off-site detector operation.

* If a broker isn't actually at the address that's provided, you get a
traceback - it should be an error message.

* In factory.py, currently every module that defines a factory method
has to be imported for the constructor registry to work correctly.  That
is ultimately a little ugly if we want client code to be decoupled from the
library - the client code would have to modify factory.py which is a library
module.  In other words, another way of doing this needs to be figured out.

* Every __init__ *has* to take an args parameter, or else the keyword args
that are passed in as part of the construction process will make it barf.
Obviously this is undesirable, but is demanding that __init__ takes an *args
parameter also undesirable?  I think it probably is, but then again how
many modules can really function without some config data...

** Maybe this could be done with an __init__ that just takes a name parameter,
and some function (extra_config?) that accepts the other arguments after
construction.

* name collisions are currently not detected _at all_, except for duplicate
endpoint or provider names.  Network names are blithely accepted.

** why is this a problem?  firing up two dripline nodes with the _exact same_ 
config files works.  imagine doing a 'get' on such a mesh, where does the 
answer actually come from?  i think it's a bad idea probably to do a full
scan of the network when you start up, as that will take absolutely ages.  
maybe using gossip is a good idea.  then a brief period of gossip at startup 
would resolve the issue (with some probability).

* fully qualified names don't actually work yet.  This should just be an issue
of adding other binding keys when we're binding the endpoint to the node.

** this is a different issue from wildcard matches.  it would be really cool
to be able to do get nodename.kv_store.* and get a list of all the keys, but
currently we can't do that.  one day.

* that reminds me, it would also be nice to be able to get all of the nodenames
that are currently attached to the network.  there's a dumb way to do this
with a timeout, probably, or a smart way to do it with gossip.  not sure what
the best way to go is right now.

* it seems like having an entire Node created for a simple agent is too 
heavyweight, but maybe it's necessary.  Think about that.

* it's clear that in the near future, a threaded Node will be necessary.  
currently you can only kill a Node with a keyboard interrupt, which isn't
actually caught by anything - so no cleanup is done.  

** a threaded node that looks at some semaphore to determine if it should
stop is probably the way to go here.  it's simple and could be controlled by 
the main thread, which could catch ctrl+c and use the semaphore to signal
the Node thread.

* raising errors from the getters and setters seems like a great way to go -
is it?  the only concern i can imagine would be confusion about why the error
got raised in the first place, but using types and messages judiciously might
clear this up.  clearly *some* error checking must be done here, as we can't
just accept anything for most modules.

* get/set on endpoint is an extremely leaky abstraction.  aren't services 
endpoints too?  and get/set doesn't really map well to what they do.  i wanted
to get away from doing runtime type checking to determine the bound methods
that an endpoint has, but it may be a necessary evil unless we can figure 
something else out.  the client doesn't need to know that something is a 
sensor or a service or whatever.

* dripline_agent needs to be way smarter.  for example, the third argument is
only there if a user calls "set", not "get".  needs fixing but i don't have
enough internet to figure out how.

* i think dripline_agent should support "describe" as an operation, where it
can tell you all about a registered node - what providers it has, what 
endpoints, and how they are all connected.  it would be a great discovery tool.

* the output from dripline_agent is stupid, it should be nicer somehow.

* the in-memory representation of Config should be better.  it's weird to parse
the YAML and then change what it looks like.  much better would be to keep the
entire parsed thing in memory and have Config provide a 'view' to it.  then
it could get modified in memory, serialized and sent around, etc etc.

** hand-in-hand with this: we should be able to ask a node to sync its config
to disk if it changes in memory.  when we call config() on a node, we expect
to get whatever config currently exists, not whatever config was used to start
the node.  

* dripline_agent needs a usage() function

* in a configuration file, we should always be sure that every endpoint is 
declared in an endpoints: block, and every provider is declared in a providers:
block.  this should always be an error if this rule is violated.

* we should catch keyword arguments that are passed to objects that don't know
what to do with them, and log it as an error instead of just winding up with
a traceback.
