#!/usr/bin/python

'''
Utility app for doing PID control
'''

from __future__ import print_function

import datetime
import pika
import argparse
import msgpack

import dripline
from dripline.core import Message, DriplineParser, constants

import logging
logger = logging.getLogger('pid_loop')
logger.setLevel(logging.DEBUG)

# this probably wants to move elsewhere eventually...
class pid_controller(object):
    '''
    '''

    def __init__(self,
                 dripline_connection,
                 output_channel,
                 goal=110,
                 proportional=0.0, integral=0.0, differential=0.0,
                 maximum=1.0, delta_I_min= 0.001,
                 **kwargs
                ):
        '''
        '''
        self.conn = dripline_connection
        self._current_channel = output_channel

        self.target_temp = goal

        self.Kproportional = proportional
        self.Kintegral = integral
        self.Kdifferential = differential

        self._integral= 0
        self._old_current = None

        self.max_current = maximum
        self.min_current_change = delta_I_min

    @property
    def target_temp(self):
        return self._target_temp
    @target_temp.setter
    def target_temp(self, value):
        self._target_temp = value
        self._integral = 0
        self._last_data = {'delta':None,'time':datetime.datetime(1970,1,1)}

    def process_new_value(self, value, timestamp):
        logger.info('value is: {}'.format(value))
        delta = self.target_temp - float(value)
        logger.info("delta is: {}".format(delta))
        this_time = datetime.datetime.strptime(timestamp, constants.TIME_FORMAT)
        self._integral += delta
        if (this_time - self._last_data['time']).seconds < (5 * 60):
            derivative = (delta - self._last_data['delta']) / (this_time - self._last_data['time']).seconds
        else:
            derivative = 0.
        self._last_data = {'delta': delta, 'time': this_time}
            
        logger.info("proportional: {}".format(self.Kproportional*delta))
        logger.info("integral: {}".format(self.Kintegral*self._integral))
        logger.info("differential: {}".format(self.Kdifferential * derivative))
        change_to_current = (self.Kproportional * delta +
                             self.Kintegral * self._integral +
                             self.Kdifferential * derivative
                            )
        new_current = (self._old_current or 0) + change_to_current
        if abs(change_to_current) < self.min_current_change:
            logger.info("current change less than min delta")
            logger.info("old[new] are: {}[{}]".format(self._old_current,new_current))
            return
        logger.info('computed new current to be: {}'.format(new_current))
        if new_current > self.max_current:
            logger.info("new current above max")
            new_current = self.max_current
        if new_current < 0.:
            logger.info("new current < 0")
            new_current = 0.
        self.set_current(new_current)
        logger.info("actual set is: {}".format(new_current))
        self._old_current = new_current

    def set_current(self, value):
        logger.debug('would set new current to: {}'.format(value))
        m = dripline.core.RequestMessage(target=self._current_channel,
                                         msgop=constants.OP_SENSOR_SET,
                                         payload=[str(value)]
                                        )
        logger.debug('request will be: {}'.format(m))
        reply = self.conn.send_request(self._current_channel, m.to_msgpack())
        result = Message.from_msgpack(reply)
        logger.debug('response was: {}'.format(result))


def start_monitoring(sensor, broker='localhost', **kwargs):
    exchange = 'alerts' # this is always alerts
    keys = ['sensor_value'] # this is always a sensor value

    connection = pika.BlockingConnection(pika.ConnectionParameters(host=broker))
    channel = connection.channel()
    #channel.exchange_declare(exchange='alerts', type='topic')
    
    result = channel.queue_declare(exclusive=True)
    queue_name = result.method.queue
    
    for severity in keys:
        channel.queue_bind(exchange=exchange,
                           queue=queue_name,
                           routing_key=severity,
                          )
    
    logger.info(' [*] Waiting for logs. To exit press CTRL+C')

    dripline_connection = dripline.core.Connection(broker)
    pid = pid_controller(dripline_connection=dripline_connection, **kwargs)
    
    def callback(ch, method, properties, body):
        message = Message.from_msgpack(body)
        message.payload = msgpack.unpackb(message.payload)
        if message['payload']['from'] == sensor:
            logger.info('got a value for sensor')
            if 'value_cal' in message['payload']['value']:
                pid.process_new_value(timestamp=message['timestamp'], value=message['payload']['value']['value_cal'])
            else:
                logger.warning('no calibrated value')
    
    channel.basic_consume(callback,
                          queue=queue_name,
                          no_ack=True)
    
    channel.start_consuming()

if __name__ == '__main__':
    parser = DriplineParser(
                            description='Print messages from an exchange',
                            extra_logger=logger,
                            amqp_broker=True,
                            tmux_support=True,
                           )
    parser.add_argument('-s',
                        '--sensor',
                        help='name of the temperature sensor to listen for',
                        required=True,
                       )
    parser.add_argument('-o',
                        '--output_channel',
                        help='name of the current limit to change',
                        required=True,
                       )
    parser.add_argument('-g',
                        '--goal',
                        help='set point temperature',
                        type=float,
                        required=True,
                       )
    parser.add_argument('-p',
                        '--proportional',
                        help='proportional PID term weighting',
                        default=0.0,
                        type=float,
                       )
    parser.add_argument('-i',
                        '--integral',
                        default=0.0,
                        type=float,
                        help='integral PID term weighting',
                       )
    parser.add_argument('-d',
                        '--differential',
                        default=0.0,
                        type=float,
                        help='differential PID term weighting',
                       )
    parser.add_argument('-m',
                        '--maximum',
                        default=0.0,
                        type=float,
                        help='maximum current value to set',
                       )
        
    kwargs = parser.parse_args()
    try:
        start_monitoring(**vars(kwargs))
    except KeyboardInterrupt:
        logger.warning(' [*] exiting')
