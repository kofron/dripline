#!/usr/bin/python
''' dpph_scan
Make a dpph based field measurement
'''

from __future__ import absolute_import

import numpy
from scipy import fftpack

import csv
import pika
import time

from dripline.core import DriplineParser, Connection, constants, Message, RequestMessage, Service

import logging
logger = logging.getLogger('dpph_scan')


def _get(name, connection):
    payload = {}
    payload.update({'values':[]})
    request = RequestMessage(msgop=constants.OP_GET,payload=payload)
    reply = connection.send_request(name, request)
    if not isinstance(reply, Message):
        result = Message.from_msgpack(reply)
    else:
        result = reply
    result_message = result.payload
    logger.debug("{}-> {}".format(name, result_message))
    return result_message


def get_data(connection):
    if not connection:
        logger.warning("no connection, can't get data")
        raise ValueError('no connection')
    data = {}
    # ensure lockin config
    _get('lockin_ensure_setup', connection)
    # trigger taking data
    result = _get('lockin_take_data', connection)
    # wait for data taking to finish
    while not result == 'done':
        time.sleep(0.2)
        result = _get('lockin_status', connection)
    # get data
    result = _get('lockin_mag_data', connection)
    data['amplitude'] = numpy.array(result.split(), dtype=float)
    result = _get('lockin_adc_data', connection)
    data['sweep_out'] = numpy.array(result.split(), dtype=float)
    return data


def WeinerFilter(freq_data, amp_data, width=False):
    if not width:
        base_width = 4
        if max(freq_data) < 30: # assume GHz
            width = base_width * 1e-3
        elif max(freq_data) < 30000: # assume MHz
            width = base_width * 1
        elif max(freq_data) < 30000000: # assume kHz
            width = base_width * 1e3
        else: # assume Hz
            width = base_width * 1e6
    data = zip(freq_data, amp_data)
    data.sort()
    f,v= zip(*data)
    frequencies = numpy.array(f, dtype=float)
    voltages = numpy.array(v, dtype=float)
    x1 = (frequencies - frequencies[0]) / width
    x2 = (frequencies - frequencies[-1]) / width
    gderiv1 = x1 * numpy.exp(-x1 * x1 / 2.)
    gderiv2 = x2 * numpy.exp(-x2 * x2 / 2.)
    target_signal = (gderiv1 + gderiv2)
    target_fft = fftpack.fft(target_signal)
    data_fft = fftpack.fft(voltages)
    data_fft[0] = 0
    filtered = fftpack.ifft(data_fft * target_fft)
    return {'freqs': frequencies,
            'result': abs(filtered),
            'target': target_signal
           }


def FrequencyToField(frequency):
    geff = 2.0036
    charge_over_mass = 1.758e11
    tesla = (4 * numpy.pi * 10**7 / (geff * charge_over_mass) * frequency)
    return tesla


def main(broker, frequency_limits, output, **kwargs):
    logger.info('broker is: {}'.format(broker))
    try:
        #connection = Connection(broker)
        connection = Service(amqp_url = broker,exchange = 'requests',keys = '#')
    except pika.exceptions.AMQPConnectionError:
        logger.error('unable to connect to broker')
        #return
        connection = False
    # confirm frequency limits
    logger.info('frequency limits are: {}'.format(frequency_limits))
    if not frequency_limits:
        pass
        # something to get them from the sweeper
        logger.warning("don't know how to get freq limits automatically")
    else:
        start_freq = min(map(float, frequency_limits))
        stop_freq = max(map(float, frequency_limits))
    # get data
    logger.info('now get data from lockin')
    lockin_data = get_data(connection)
    # map adc values to frequencies
    logger.info('map sweep out to frequencies')
    m = (stop_freq - start_freq) / (10.)
    lockin_data['frequencies'] = start_freq + m * lockin_data['sweep_out']
    # pass data to filter
    logger.info('do optimal filter on output')
    filter_data = WeinerFilter(lockin_data['frequencies'], lockin_data['amplitude'])
    res_freq = filter_data['freqs'][filter_data['result']==filter_data['result'].max()]
    # save raw output to file if requested
    if output:
        output_file = open(output, 'w')
        csv_writer = csv.writer(output_file)
        csv_writer.writerow(['sweep_out',
                             'sweep_freqs',
                             'lockin_signal',
                             'filter_freqs',
                             'filter_target',
                             'filter_result',
                            ])
        csv_writer.writerows(zip(lockin_data['sweep_out'],
                                 lockin_data['frequencies'],
                                 lockin_data['amplitude'],
                                 filter_data['freqs'],
                                 filter_data['target'],
                                 filter_data['result'],
                                ))
        output_file.close()
    # make plot if requested
    # prompt user for approval to log if requested
    # print field result
    logger.info("compute field")
    field = FrequencyToField(filter_data['freqs'][filter_data['result']==filter_data['result'].max()])
    print('value is: {}'.format(field))


if __name__ == '__main__':
    scan_doc = '''
               dpph_scan performs a dpph scan and field estimate
               '''
    parser = DriplineParser(description=scan_doc,
                            extra_logger=logger,
                            amqp_broker=True,
                            tmux_support=True,
                            twitter_support=True,
                           )
    # an option for outputting raw data
    parser.add_argument('-o', '--output', default=False)
    # an option for outputting a grahic
    # an option for passing in the sweeper limits
    parser.add_argument('-f', '--frequency-limits', nargs=2, default=[])
    # an option to log the result (have this prompt the user first?)
    args = parser.parse_args()
    main(**vars(args))
