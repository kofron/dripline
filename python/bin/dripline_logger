#!/usr/bin/python
'''
A brute force first pass version of a logger.
'''

import argparse
import code
import datetime
import sqlite3
from multiprocessing import Process
from time import sleep
import uuid
import yaml

import dripline


def add_to_log(connection, name, payload, time):
    cursor = connection.cursor()
    insert_str = 'INSERT INTO {} VALUES (?, ?)'.format(name)
    cursor.execute(insert_str, (time, payload))
    connection.commit()

class LogManager:
    '''
    Management of many parallel/independent brute force loggers
    '''

    def __init__(self, dbfile, broker, endpoints):
        self.conn = sqlite3.connect(dbfile)
        self.broker = broker
        self.loggers = []
        self.process_list = []
        self.endpoints = {d['name']:d['interval'] for d in endpoints}
        self._EnsureTables()
        self.SetupLoggers()

    @classmethod
    def from_yaml(cls, conf):
        return cls(dbfile=conf['dbfile'],
                   broker=conf['broker'],
                   endpoints=conf['endpoints'],
                   )

    def _EnsureTables(self):
        for endpoint in self.endpoints.keys():
            cur = self.conn.cursor()
            cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
            existing = cur.fetchall()
            if (endpoint,) in existing:
                continue
            new_str = 'CREATE TABLE {} (date text, value text)'.format(endpoint)
            cur.execute(new_str)
            self.conn.commit()

    def SetupLoggers(self):
        '''
        Clear the list of loggers and regenerate it from the self.endpoints dict
        '''
        self.loggers = []
        print(self.endpoints)
        for name,time in self.endpoints.iteritems():
            self.loggers.append(BruteLogger(self.conn, self.broker, name, time))

    def StartLoggers(self):
        self.StopLoggers()
        self.process_list = [Process(target=logger) for logger in self.loggers]
        for p in self.process_list:
            p.start()

    def StopLoggers(self):
        for p in self.process_list:
            p.terminate()
        self.process_list = []

class BruteLogger:
    '''
    A class to do brute force logging of a single endpoint.
    '''

    def __init__(self, db_connection, broker, endpoint_name, interval):
        '''
        db_connection: a connection to database
        endpoint_name: name of an active endpoint
        interval: time, in seconds, between logging of values
        '''
        self.end_name = endpoint_name
        self.interval = interval
        self.conn = db_connection

        node_name = uuid.uuid4().hex[1:9]
        yaml_conf = """
                    'broker': {}\n
                    'nodename': {}
                    """.format(broker, node_name)
        self.node = dripline.core.Node(dripline.core.Config(yaml_string=yaml_conf))

    def __call__(self):
        self.StartLogLoop()

    def StartLogLoop(self):
        while True:
            self._LogChannel()
            sleep(self.interval)

    def _LogChannel(self):
        req = dripline.core.RequestMessage(target=self.end_name,
                                           msgop=dripline.core.OP_GET,
                                           )
        resp = self.node.send_sync(req)
        add_to_log(self.conn, self.end_name, resp.payload, resp.timestamp) #datetime.datetime.now())

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Start logging endpoints')
    parser.add_argument('-c', '--config',
                        metavar='configuration file',
                        help='path to YAML configuration file',
                        )
    parsed = parser.parse_args()
    conf = yaml.safe_load(open(parsed.config).read())
    log_manage = LogManager.from_yaml(conf)
    log_manage.StartLoggers()
    context = globals()
    context.update({'log_manager':log_manage})
    welcome_str = 'Welcome to the brute force logger.\n'
    info_str = 'you can stop with log_manager.StopLoggers()'
    code.InteractiveConsole(context).interact(welcome_str+info_str)
